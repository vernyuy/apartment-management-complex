import { Utility } from '@aws-lambda-powertools/commons';
import type { HandlerMethodDecorator } from '@aws-lambda-powertools/commons/types';
import { type MetricsOptions, type Dimensions, type EmfOutput, type ExtraOptions, type MetricsInterface, type MetricUnit, type MetricResolution } from './types/index.js';
/**
 * ## Intro
 * Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF).
 *
 * These metrics can be visualized through Amazon CloudWatch Console.
 *
 * ## Key features
 *   * Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob)
 *   * Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc)
 *   * Metrics are created asynchronously by CloudWatch service, no custom stacks needed
 *   * Context manager to create a one off metric with a different dimension
 *
 * ## Usage
 *
 * ### Functions usage with middleware
 *
 * Using this middleware on your handler function will automatically flush metrics after the function returns or throws an error.
 * Additionally, you can configure the middleware to easily:
 * * ensure that at least one metric is emitted before you flush them
 * * capture a `ColdStart` a metric
 * * set default dimensions for all your metrics
 *
 * @example
 * ```typescript
 * import { Metrics } from '@aws-lambda-powertools/metrics';
 * import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';
 * import middy from '@middy/core';
 *
 * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
 *
 * const lambdaHandler = async (_event: unknown, _context: unknown) => {
 *   ...
 * };
 *
 * export const handler = middy(lambdaHandler).use(logMetrics(metrics));
 * ```
 *
 * ### Object oriented way with decorator
 *
 * If you are used to TypeScript Class usage to encapsulate your Lambda handler you can leverage the [@metrics.logMetrics()](./_aws_lambda_powertools_metrics.Metrics.html#logMetrics) decorator to automatically:
 *   * capture a `ColdStart` metric
 *   * flush buffered metrics
 *   * throw on empty metrics
 *
 * @example
 *
 * ```typescript
 * import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
 * import type { LambdaInterface } from '@aws-lambda-powertools/commons/types';
 *
 * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
 *
 * class Lambda implements LambdaInterface {
 *   // Decorate your handler with the logMetrics decorator
 *   ‚Å£@metrics.logMetrics({ captureColdStartMetric: true, throwOnEmptyMetrics: true })
 *   public handler(_event: unknown, _context: unknown): Promise<void> {
 *     // ...
 *     metrics.addMetric('test-metric', MetricUnit.Count, 10);
 *     // ...
 *   }
 * }
 *
 * const handlerClass = new Lambda();
 * export const handler = handlerClass.handler.bind(handlerClass);
 * ```
 *
 * ### Standard function
 *
 * If you are used to classic JavaScript functions, you can leverage the different methods provided to create and publish metrics.
 *
 * @example
 *
 * ```typescript
 * import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
 *
 * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
 *
 * export const handler = async (_event: unknown, __context: unknown): Promise<void> => {
 *   metrics.captureColdStartMetric();
 *   metrics.addMetric('test-metric', MetricUnit.Count, 10);
 *   metrics.publishStoredMetrics();
 * };
 * ```
 */
declare class Metrics extends Utility implements MetricsInterface {
    /**
     * Console instance used to print logs.
     *
     * In AWS Lambda, we create a new instance of the Console class so that we can have
     * full control over the output of the logs. In testing environments, we use the
     * default console instance.
     *
     * This property is initialized in the constructor in setOptions().
     *
     * @private
     */
    private console;
    private customConfigService?;
    private defaultDimensions;
    private dimensions;
    private envVarsService?;
    private functionName?;
    private isSingleMetric;
    private metadata;
    private namespace?;
    private shouldThrowOnEmptyMetrics;
    private storedMetrics;
    constructor(options?: MetricsOptions);
    /**
     * Add a dimension to the metrics.
     *
     * A dimension is a key-value pair that is used to group metrics.
     *
     * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension for more details.
     * @param name
     * @param value
     */
    addDimension(name: string, value: string): void;
    /**
     * Add multiple dimensions to the metrics.
     *
     * A dimension is a key-value pair that is used to group metrics.
     *
     * @param dimensions A key-value pair of dimensions
     */
    addDimensions(dimensions: {
        [key: string]: string;
    }): void;
    /**
     * A high-cardinality data part of your Metrics log.
     *
     * This is useful when you want to search highly contextual information along with your metrics in your logs.
     *
     * @param key The key of the metadata
     * @param value The value of the metadata
     */
    addMetadata(key: string, value: string): void;
    /**
     * Add a metric to the metrics buffer.
     *
     * By default, metrics are buffered and flushed at the end of the Lambda invocation
     * or when calling {@link Metrics.publishStoredMetrics}.
     *
     * You can add a metric by specifying the metric name, unit, and value. For convenience,
     * we provide a set of constants for the most common units in {@link MetricUnit}.
     *
     * @example
     * ```typescript
     * import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
     *
     * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
     *
     * metrics.addMetric('successfulBooking', MetricUnit.Count, 1);
     * ```
     *
     * Optionally, you can specify the metric resolution, which can be either `High` or `Standard`.
     * By default, metrics are published with a resolution of `Standard`, click [here](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Resolution_definition)
     * to learn more about metric resolutions.
     *
     * @example
     * ```typescript
     * import { Metrics, MetricUnit, MetricResolution } from '@aws-lambda-powertools/metrics';
     *
     * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
     *
     * metrics.addMetric('successfulBooking', MetricUnit.Count, 1, MetricResolution.High);
     * ```
     *
     * @param name - The metric name
     * @param unit - The metric unit
     * @param value - The metric value
     * @param resolution - The metric resolution
     */
    addMetric(name: string, unit: MetricUnit, value: number, resolution?: MetricResolution): void;
    /**
     * Create a singleMetric to capture cold start.
     *
     * If it's a cold start invocation, this feature will:
     *   * Create a separate EMF blob that contains a single metric named ColdStart
     *   * Add function_name and service dimensions
     *
     * This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions,
     * as well as avoiding potential data loss from metrics not being published for other reasons.
     *
     * @example
     * ```typescript
     * import { Metrics } from '@aws-lambda-powertools/metrics';
     *
     * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
     *
     * export const handler = async (_event: unknown, __context: unknown): Promise<void> => {
     *     metrics.captureColdStartMetric();
     * };
     * ```
     */
    captureColdStartMetric(): void;
    /**
     * Clear all default dimensions.
     */
    clearDefaultDimensions(): void;
    /**
     * Clear all dimensions.
     */
    clearDimensions(): void;
    /**
     * Clear all metadata.
     */
    clearMetadata(): void;
    /**
     * Clear all the metrics stored in the buffer.
     */
    clearMetrics(): void;
    /**
     * A decorator automating coldstart capture, throw on empty metrics and publishing metrics on handler exit.
     *
     * @example
     *
     * ```typescript
     * import { Metrics } from '@aws-lambda-powertools/metrics';
     * import type { LambdaInterface } from '@aws-lambda-powertools/commons/types';
     *
     * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
     *
     * class Lambda implements LambdaInterface {
     *   @metrics.logMetrics({ captureColdStartMetric: true })
     *   public handler(_event: unknown, __context: unknown): Promise<void> {
     *     // ...
     *   }
     * }
     *
     * const handlerClass = new Lambda();
     * export const handler = handlerClass.handler.bind(handlerClass);
     * ```
     *
     * @decorator Class
     */
    logMetrics(options?: ExtraOptions): HandlerMethodDecorator;
    /**
     * Synchronous function to actually publish your metrics. (Not needed if using logMetrics decorator).
     * It will create a new EMF blob and log it to standard output to be then ingested by Cloudwatch logs and processed automatically for metrics creation.
     *
     * @example
     *
     * ```typescript
     * import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
     *
     * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' }); // Sets metric namespace, and service as a metric dimension
     *
     * export const handler = async (_event: unknown, __context: unknown): Promise<void> => {
     *   metrics.addMetric('test-metric', MetricUnit.Count, 10);
     *   metrics.publishStoredMetrics();
     * };
     * ```
     */
    publishStoredMetrics(): void;
    /**
     * Function to create a new metric object compliant with the EMF (Embedded Metric Format) schema which
     * includes the metric name, unit, and optionally storage resolution.
     *
     * The function will create a new EMF blob and log it to standard output to be then ingested by Cloudwatch
     * logs and processed automatically for metrics creation.
     *
     * @returns metrics as JSON object compliant EMF Schema Specification
     * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html for more details
     */
    serializeMetrics(): EmfOutput;
    /**
     * Sets default dimensions that will be added to all metrics.
     *
     * @param dimensions The default dimensions to be added to all metrics.
     */
    setDefaultDimensions(dimensions: Dimensions | undefined): void;
    /**
     * Sets the function name to be added to the metric.
     *
     * @param value The function name to be added to the metric.
     */
    setFunctionName(value: string): void;
    /**
     * CloudWatch EMF uses the same dimensions across all your metrics. Use singleMetric if you have a metric that should have different dimensions.
     *
     * You don't need to call publishStoredMetrics() after calling addMetric for a singleMetrics, they will be flushed directly.
     *
     * @example
     *
     * ```typescript
     * const singleMetric = metrics.singleMetric();
     * singleMetric.addDimension('InnerDimension', 'true');
     * singleMetric.addMetric('single-metric', MetricUnit.Percent, 50);
     * ```
     *
     * @returns the Metrics
     */
    singleMetric(): Metrics;
    /**
     * Throw an Error if the metrics buffer is empty.
     *
     * @example
     *
     * ```typescript
     * import { Metrics } from '@aws-lambda-powertools/metrics';
     *
     * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName:'orders' });
     *
     * export const handler = async (_event: unknown, __context: unknown): Promise<void> => {
     *     metrics.throwOnEmptyMetrics();
     *     metrics.publishStoredMetrics(); // will throw since no metrics added.
     * };
     * ```
     */
    throwOnEmptyMetrics(): void;
    /**
     * Gets the current number of dimensions stored.
     *
     * @returns the number of dimensions currently stored
     */
    private getCurrentDimensionsCount;
    /**
     * Gets the custom config service if it exists.
     *
     * @returns the custom config service if it exists, undefined otherwise
     */
    private getCustomConfigService;
    /**
     * Gets the environment variables service.
     *
     * @returns the environment variables service
     */
    private getEnvVarsService;
    /**
     * Checks if a metric is new or not.
     *
     * A metric is considered new if there is no metric with the same name already stored.
     *
     * When a metric is not new, we also check if the unit is consistent with the stored metric with
     * the same name. If the units are inconsistent, we throw an error as this is likely a bug or typo.
     * This can happen if a metric is added without using the `MetricUnit` helper in JavaScript codebases.
     *
     * @param name The name of the metric
     * @param unit The unit of the metric
     * @returns true if the metric is new, false if another metric with the same name already exists
     */
    private isNewMetric;
    /**
     * It initializes console property as an instance of the internal version of Console() class (PR #748)
     * or as the global node console if the `POWERTOOLS_DEV' env variable is set and has truthy value.
     *
     * @private
     * @returns {void}
     */
    private setConsole;
    /**
     * Sets the custom config service to be used.
     *
     * @param customConfigService The custom config service to be used
     */
    private setCustomConfigService;
    /**
     * Sets the environment variables service to be used.
     */
    private setEnvVarsService;
    /**
     * Sets the namespace to be used.
     *
     * @param namespace The namespace to be used
     */
    private setNamespace;
    /**
     * Sets the options to be used by the Metrics instance.
     *
     * This method is used during the initialization of the Metrics instance.
     *
     * @param options The options to be used
     * @returns the Metrics instance
     */
    private setOptions;
    /**
     * Sets the service to be used.
     *
     * @param service The service to be used
     */
    private setService;
    /**
     * Stores a metric in the buffer.
     *
     * If the buffer is full, or the metric reaches the maximum number of values,
     * the buffer is published to stdout.
     *
     * @param name The name of the metric to store
     * @param unit The unit of the metric to store
     * @param value The value of the metric to store
     * @param resolution The resolution of the metric to store
     */
    private storeMetric;
}
export { Metrics };
//# sourceMappingURL=Metrics.d.ts.map