"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logMetrics = void 0;
const commons_1 = require("@aws-lambda-powertools/commons");
/**
 * A middy middleware automating capture of metadata and annotations on segments or subsegments for a Lambda Handler.
 *
 * Using this middleware on your handler function will automatically flush metrics after the function returns or throws an error.
 * Additionally, you can configure the middleware to easily:
 * * ensure that at least one metric is emitted before you flush them
 * * capture a `ColdStart` a metric
 * * set default dimensions for all your metrics
 *
 * @example
 * ```typescript
 * import { Metrics } from '@aws-lambda-powertools/metrics';
 * import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';
 * import middy from '@middy/core';
 *
 * const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });
 *
 * const lambdaHandler = async (_event: any, _context: any) => {
 *   ...
 * };
 *
 * export const handler = middy(lambdaHandler).use(logMetrics(metrics));
 * ```
 *
 * @param target - The Metrics instance to use for emitting metrics
 * @param options - (_optional_) Options for the middleware
 * @returns middleware - The middy middleware object
 */
const logMetrics = (target, options = {}) => {
    const metricsInstances = target instanceof Array ? target : [target];
    /**
     * Set the cleanup function to be called in case other middlewares return early.
     *
     * @param request - The request object
     */
    const setCleanupFunction = (request) => {
        request.internal = {
            ...request.internal,
            [commons_1.METRICS_KEY]: logMetricsAfterOrError,
        };
    };
    const logMetricsBefore = async (request) => {
        metricsInstances.forEach((metrics) => {
            metrics.setFunctionName(request.context.functionName);
            const { throwOnEmptyMetrics, defaultDimensions, captureColdStartMetric } = options;
            if (throwOnEmptyMetrics) {
                metrics.throwOnEmptyMetrics();
            }
            if (defaultDimensions !== undefined) {
                metrics.setDefaultDimensions(defaultDimensions);
            }
            if (captureColdStartMetric) {
                metrics.captureColdStartMetric();
            }
        });
        setCleanupFunction(request);
    };
    const logMetricsAfterOrError = async () => {
        metricsInstances.forEach((metrics) => {
            metrics.publishStoredMetrics();
        });
    };
    return {
        before: logMetricsBefore,
        after: logMetricsAfterOrError,
        onError: logMetricsAfterOrError,
    };
};
exports.logMetrics = logMetrics;
