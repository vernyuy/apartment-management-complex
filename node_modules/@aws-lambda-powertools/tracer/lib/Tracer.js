"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracer = void 0;
const commons_1 = require("@aws-lambda-powertools/commons");
const config_1 = require("./config");
const provider_1 = require("./provider");
const aws_xray_sdk_core_1 = require("aws-xray-sdk-core");
/**
 * ## Intro
 * Tracer is an opinionated thin wrapper for [AWS X-Ray SDK for Node.js](https://github.com/aws/aws-xray-sdk-node).
 *
 * Tracing data can be visualized through AWS X-Ray Console.
 *
 * ## Key features
 *   * Auto capture cold start as annotation, and responses or full exceptions as metadata
 *   * Auto-disable when not running in AWS Lambda environment
 *   * Automatically trace HTTP(s) clients and generate segments for each request
 *   * Support tracing functions via decorators, middleware, and manual instrumentation
 *   * Support tracing AWS SDK v2 and v3 via AWS X-Ray SDK for Node.js
 *
 * ## Usage
 *
 * For more usage examples, see [our documentation](https://awslabs.github.io/aws-lambda-powertools-typescript/latest/core/tracer/).
 *
 * ### Functions usage with middleware
 *
 * If you use function-based Lambda handlers you can use the [captureLambdaHandler()](./_aws_lambda_powertools_tracer.Tracer.html) middy middleware to automatically:
 * * handle the subsegment lifecycle
 * * add the `ServiceName` and `ColdStart` annotations
 * * add the function response as metadata
 * * add the function error as metadata (if any)
 *
 * @example
 * ```typescript
 * import { captureLambdaHandler, Tracer } from '@aws-lambda-powertools/tracer';
 * import middy from '@middy/core';
 *
 * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
 *
 * export const handler = middy(async (_event: any, _context: any) => {
 *   ...
 * }).use(captureLambdaHandler(tracer));
 * ```
 *
 * ### Object oriented usage with decorators
 *
 * If instead you use TypeScript Classes to wrap your Lambda handler you can use the [@tracer.captureLambdaHandler()](./_aws_lambda_powertools_tracer.Tracer.html#captureLambdaHandler) decorator to automatically:
 * * handle the subsegment lifecycle
 * * add the `ServiceName` and `ColdStart` annotations
 * * add the function response as metadata
 * * add the function error as metadata (if any)
 *
 * @example
 * ```typescript
 * import { Tracer } from '@aws-lambda-powertools/tracer';
 *
 * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
 *
 * // FYI: Decorator might not render properly in VSCode mouse over due to https://github.com/microsoft/TypeScript/issues/39371 and might show as *@tracer* instead of `@tracer.captureLambdaHandler`
 *
 * class Lambda {
 *   @tracer.captureLambdaHandler()
 *   public handler(event: any, context: any) {
 *     ...
 *   }
 * }
 *
 * export const handlerClass = new Lambda();
 * export const handler = handlerClass.handler;
 * ```
 *
 * ### Functions usage with manual instrumentation
 *
 * If you prefer to manually instrument your Lambda handler you can use the methods in the tracer class directly.
 *
 * @example
 * ```typescript
 * import { Tracer } from '@aws-lambda-powertools/tracer';
 * import { Segment } from 'aws-xray-sdk-core';
 *
 * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
 *
 * export const handler = async (_event: any, context: any) => {
 *   const segment = tracer.getSegment(); // This is the facade segment (the one that is created by AWS Lambda)
 *   // Create subsegment for the function & set it as active
 *   const subsegment = segment.addNewSubsegment(`## ${process.env._HANDLER}`);
 *   tracer.setSegment(subsegment);
 *
 *   // Annotate the subsegment with the cold start & serviceName
 *   tracer.annotateColdStart();
 *   tracer.addServiceNameAnnotation();
 *
 *   let res;
 *   try {
 *       res = ...
 *       // Add the response as metadata
 *       tracer.addResponseAsMetadata(res, process.env._HANDLER);
 *   } catch (err) {
 *       // Add the error as metadata
 *       tracer.addErrorAsMetadata(err as Error);
 *       throw err;
 *   } finally {
 *       // Close the subsegment
 *       subsegment.close();
 *       // Set the facade segment as active again
 *       tracer.setSegment(segment);
 *   }
 *
 *   return res;
 * }
 * ```
 */
class Tracer extends commons_1.Utility {
    constructor(options = {}) {
        super();
        this.captureError = true;
        this.captureHTTPsRequests = true;
        this.captureResponse = true;
        this.tracingEnabled = true;
        this.setOptions(options);
        this.provider = new provider_1.ProviderService();
        if (this.isTracingEnabled() && this.captureHTTPsRequests) {
            this.provider.captureHTTPsGlobal();
        }
        if (!this.isTracingEnabled()) {
            // Tell x-ray-sdk to not throw an error if context is missing but tracing is disabled
            this.provider.setContextMissingStrategy(() => ({}));
        }
    }
    /**
      * Add an error to the current segment or subsegment as metadata.
      *
      * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-errors
      *
      * @param error - Error to serialize as metadata
      */
    addErrorAsMetadata(error) {
        if (!this.isTracingEnabled()) {
            return;
        }
        const subsegment = this.getSegment();
        if (!this.captureError) {
            subsegment.addErrorFlag();
            return;
        }
        subsegment.addError(error, false);
    }
    /**
      * Add response data to the current segment or subsegment as metadata.
      *
      * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-annotations
      *
      * @param data - Data to serialize as metadata
      * @param methodName - Name of the method that is being traced
      */
    addResponseAsMetadata(data, methodName) {
        if (data === undefined || !this.captureResponse || !this.isTracingEnabled()) {
            return;
        }
        this.putMetadata(`${methodName} response`, data);
    }
    /**
     * Add service name to the current segment or subsegment as annotation.
     *
     */
    addServiceNameAnnotation() {
        if (!this.isTracingEnabled() || this.serviceName === undefined) {
            return;
        }
        this.putAnnotation('Service', this.serviceName);
    }
    /**
     * Add ColdStart annotation to the current segment or subsegment.
     *
     * If Tracer has been initialized outside the Lambda handler then the same instance
     * of Tracer will be reused throughout the lifecycle of that same Lambda execution environment
     * and this method will annotate `ColdStart: false` after the first invocation.
     *
     * @see https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html
     */
    annotateColdStart() {
        if (this.isTracingEnabled()) {
            this.putAnnotation('ColdStart', this.getColdStart());
        }
    }
    /**
     * Patch all AWS SDK v2 clients and create traces when your application makes calls to AWS services.
     *
     * If you want to patch a specific client use {@link captureAWSClient} and if you are using AWS SDK v3 use {@link captureAWSv3Client} instead.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-awssdkclients.html
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     * const AWS = tracer.captureAWS(require('aws-sdk'));
     *
     * export const handler = async (_event: any, _context: any) => {
     *   ...
     * }
     * ```
     *
     * @param aws - AWS SDK v2 import
     * @returns AWS - Instrumented AWS SDK
     */
    captureAWS(aws) {
        if (!this.isTracingEnabled())
            return aws;
        return this.provider.captureAWS(aws);
    }
    /**
     * Patch a specific AWS SDK v2 client and create traces when your application makes calls to that AWS service.
     *
     * If you want to patch all clients use {@link captureAWS} and if you are using AWS SDK v3 use {@link captureAWSv3Client} instead.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-awssdkclients.html
     *
     * @example
     * ```typescript
     * import { S3 } from "aws-sdk";
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     * const s3 = tracer.captureAWSClient(new S3({ apiVersion: "2006-03-01" }));
     *
     * export const handler = async (_event: any, _context: any) => {
     *   ...
     * }
     * ```
     *
     * @param service - AWS SDK v2 client
     * @returns service - Instrumented AWS SDK v2 client
     */
    captureAWSClient(service) {
        if (!this.isTracingEnabled())
            return service;
        try {
            return this.provider.captureAWSClient(service);
        }
        catch (error) {
            try {
                // This is needed because some aws-sdk clients like AWS.DynamoDB.DocumentDB don't comply with the same
                // instrumentation contract like most base clients. 
                // For detailed explanation see: https://github.com/awslabs/aws-lambda-powertools-typescript/issues/524#issuecomment-1024493662
                this.provider.captureAWSClient(service.service);
                return service;
            }
            catch {
                throw error;
            }
        }
    }
    /**
     * Patch an AWS SDK v3 client and create traces when your application makes calls to that AWS service.
     *
     * If you are using AWS SDK v2 use {@link captureAWSClient} instead.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-awssdkclients.html
     *
     * @example
     * ```typescript
     * import { S3Client } from "@aws-sdk/client-s3";
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     * const client = new S3Client({});
     * tracer.captureAWSv3Client(client);
     *
     * export const handler = async (_event: any, _context: any) => {
     *   ...
     * }
     * ```
     *
     * @param service - AWS SDK v3 client
     * @returns service - Instrumented AWS SDK v3 client
     */
    captureAWSv3Client(service) {
        if (!this.isTracingEnabled())
            return service;
        return this.provider.captureAWSv3Client(service);
    }
    /**
     * A decorator automating capture of metadata and annotations on segments or subsegments for a Lambda Handler.
     *
     * Using this decorator on your handler function will automatically:
     * * handle the subsegment lifecycle
     * * add the `ColdStart` annotation
     * * add the function response as metadata
     * * add the function error as metadata (if any)
     *
     * Note: Currently TypeScript only supports decorators on classes and methods. If you are using the
     * function syntax, you should use the middleware instead.
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     *
     * class Lambda {
     *   @tracer.captureLambdaHandler()
     *   public handler(event: any, context: any) {
     *     ...
     *   }
     * }
     *
     * export const handlerClass = new Lambda();
     * export const handler = handlerClass.handler;
     * ```
     *
     * @decorator Class
     */
    captureLambdaHandler() {
        return (target, _propertyKey, descriptor) => {
            const originalMethod = descriptor.value;
            descriptor.value = ((event, context, callback) => {
                if (!this.isTracingEnabled()) {
                    return originalMethod?.apply(target, [event, context, callback]);
                }
                return this.provider.captureAsyncFunc(`## ${process.env._HANDLER}`, async (subsegment) => {
                    this.annotateColdStart();
                    this.addServiceNameAnnotation();
                    let result;
                    try {
                        result = await originalMethod?.apply(target, [event, context, callback]);
                        this.addResponseAsMetadata(result, process.env._HANDLER);
                    }
                    catch (error) {
                        this.addErrorAsMetadata(error);
                        throw error;
                    }
                    finally {
                        subsegment?.close();
                        subsegment?.flush();
                    }
                    return result;
                });
            });
            return descriptor;
        };
    }
    /**
     * A decorator automating capture of metadata and annotations on segments or subsegments for an arbitrary function.
     *
     * Using this decorator on your function will automatically:
     * * handle the subsegment lifecycle
     * * add the function response as metadata
     * * add the function error as metadata (if any)
     *
     * Note: Currently TypeScript only supports decorators on classes and methods. If you are using the
     * function syntax, you should use the middleware instead.
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     *
     * class Lambda {
     *   @tracer.captureMethod()
     *   public myMethod(param: any) {
     *     ...
     *   }
     *
     *   public handler(event: any, context: any) {
     *     ...
     *   }
     * }
     *
     * export const handlerClass = new Lambda();
     * export const myMethod = handlerClass.myMethod;
     * export const handler = handlerClass.handler;
     * ```
     *
     * @decorator Class
     */
    captureMethod() {
        return (target, _propertyKey, descriptor) => {
            const originalMethod = descriptor.value;
            descriptor.value = (...args) => {
                if (!this.isTracingEnabled()) {
                    return originalMethod?.apply(target, [...args]);
                }
                return this.provider.captureAsyncFunc(`### ${originalMethod.name}`, async (subsegment) => {
                    let result;
                    try {
                        result = await originalMethod?.apply(this, [...args]);
                        this.addResponseAsMetadata(result, originalMethod.name);
                    }
                    catch (error) {
                        this.addErrorAsMetadata(error);
                        // TODO: should this error be thrown?? If thrown we get a ERR_UNHANDLED_REJECTION. If not aren't we are basically catching a Customer error?
                        // throw error;
                    }
                    finally {
                        subsegment?.close();
                    }
                    return result;
                });
            };
            return descriptor;
        };
    }
    /**
     * Get the active segment or subsegment in the current scope.
     *
     * Usually you won't need to call this method unless you are creating custom subsegments or using manual mode.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-segments
     * @see https://awslabs.github.io/aws-lambda-powertools-typescript/latest/core/tracer/#escape-hatch-mechanism
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     *
     * export const handler = async (_event: any, _context: any) => {
     *   const currentSegment = tracer.getSegment();
     *   ... // Do something with segment
     * }
     * ```
     *
     * @returns segment - The active segment or subsegment in the current scope.
     */
    getSegment() {
        if (!this.isTracingEnabled()) {
            return new aws_xray_sdk_core_1.Subsegment('## Dummy segment');
        }
        const segment = this.provider.getSegment();
        if (segment === undefined) {
            throw new Error('Failed to get the current sub/segment from the context.');
        }
        return segment;
    }
    /**
     * Get the current value of the `tracingEnabled` property.
     *
     * You can use this method during manual instrumentation to determine
     * if tracer is currently enabled.
     *
     * @returns tracingEnabled - `true` if tracing is enabled, `false` otherwise.
     */
    isTracingEnabled() {
        return this.tracingEnabled;
    }
    /**
     * Adds annotation to existing segment or subsegment.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-segment.html#xray-sdk-nodejs-segment-annotations
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     *
     * export const handler = async (_event: any, _context: any) => {
     *   tracer.putAnnotation('successfulBooking', true);
     * }
     * ```
     *
     * @param key - Annotation key
     * @param value - Value for annotation
     */
    putAnnotation(key, value) {
        if (!this.isTracingEnabled())
            return;
        const document = this.getSegment();
        if (document instanceof aws_xray_sdk_core_1.Segment) {
            console.warn('You cannot annotate the main segment in a Lambda execution environment');
            return;
        }
        document?.addAnnotation(key, value);
    }
    /**
     * Adds metadata to existing segment or subsegment.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-segment.html#xray-sdk-nodejs-segment-metadata
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     *
     * export const handler = async (_event: any, _context: any) => {
     *   const res = someLogic();
     *   tracer.putMetadata('paymentResponse', res);
     * }
     * ```
     *
     * @param key - Metadata key
     * @param value - Value for metadata
     * @param namespace - Namespace that metadata will lie under, if none is passed it will use the serviceName
     */
    putMetadata(key, value, namespace) {
        if (!this.isTracingEnabled())
            return;
        const document = this.getSegment();
        if (document instanceof aws_xray_sdk_core_1.Segment) {
            console.warn('You cannot add metadata to the main segment in a Lambda execution environment');
            return;
        }
        namespace = namespace || this.serviceName;
        document?.addMetadata(key, value, namespace);
    }
    /**
     * Sets the passed subsegment as the current active subsegment.
     *
     * If you are using a middleware or a decorator this is done automatically for you.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-subsegments.html
     *
     * @example
     * ```typescript
     * import { Tracer } from '@aws-lambda-powertools/tracer';
     * import { Segment } from 'aws-xray-sdk-core';
     *
     * const tracer = new Tracer({ serviceName: 'serverlessAirline' });
     *
     * export const handler = async (_event: any, _context: any) => {
     *   const subsegment = new Subsegment('### foo.bar');
     *   tracer.setSegment(subsegment);
     * }
     * ```
     *
     * @param segment - Subsegment to set as the current segment
     */
    setSegment(segment) {
        if (!this.isTracingEnabled())
            return;
        return this.provider.setSegment(segment);
    }
    /**
     * Getter for `customConfigService`.
     * Used internally during initialization.
     */
    getCustomConfigService() {
        return this.customConfigService;
    }
    /**
     * Getter for `envVarsService`.
     * Used internally during initialization.
     */
    getEnvVarsService() {
        return this.envVarsService;
    }
    /**
     * Determine if we are running in a Lambda execution environment.
     * Used internally during initialization.
     */
    isLambdaExecutionEnv() {
        return this.getEnvVarsService()?.getAwsExecutionEnv() !== '';
    }
    /**
     * Determine if we are running inside a SAM CLI process.
     * Used internally during initialization.
     */
    isLambdaSamCli() {
        return this.getEnvVarsService()?.getSamLocal() !== '';
    }
    /**
     * Validate that the service name provided is valid.
     * Used internally during initialization.
     *
     * @param serviceName - Service name to validate
     */
    static isValidServiceName(serviceName) {
        return typeof serviceName === 'string' && serviceName.trim().length > 0;
    }
    /**
     * Setter for `captureError` based on configuration passed and environment variables.
     * Used internally during initialization.
     */
    setCaptureError() {
        const customConfigValue = this.getCustomConfigService()?.getTracingCaptureError();
        if (customConfigValue !== undefined && customConfigValue.toLowerCase() === 'false') {
            this.captureError = false;
            return;
        }
        const envVarsValue = this.getEnvVarsService()?.getTracingCaptureError();
        if (envVarsValue.toLowerCase() === 'false') {
            this.captureError = false;
            return;
        }
    }
    /**
     * Patch all HTTP(s) clients and create traces when your application makes calls outgoing calls.
     *
     * Calls using third-party HTTP request libraries, such as Axios, are supported as long as they use the native http
     * module under the hood. Support for third-party HTTP request libraries is provided on a best effort basis.
     *
     * @see https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-nodejs-httpclients.html
     *
     * @param enabled - Whether or not to patch all HTTP clients
     * @returns void
     */
    setCaptureHTTPsRequests(enabled) {
        if (enabled !== undefined && !enabled) {
            this.captureHTTPsRequests = false;
            return;
        }
        const customConfigValue = this.getCustomConfigService()?.getCaptureHTTPsRequests();
        if (customConfigValue !== undefined && customConfigValue.toLowerCase() === 'false') {
            this.captureHTTPsRequests = false;
            return;
        }
        const envVarsValue = this.getEnvVarsService()?.getCaptureHTTPsRequests();
        if (envVarsValue.toLowerCase() === 'false') {
            this.captureHTTPsRequests = false;
            return;
        }
    }
    /**
     * Setter for `captureResponse` based on configuration passed and environment variables.
     * Used internally during initialization.
     */
    setCaptureResponse() {
        const customConfigValue = this.getCustomConfigService()?.getTracingCaptureResponse();
        if (customConfigValue !== undefined && customConfigValue.toLowerCase() === 'false') {
            this.captureResponse = false;
            return;
        }
        const envVarsValue = this.getEnvVarsService()?.getTracingCaptureResponse();
        if (envVarsValue.toLowerCase() === 'false') {
            this.captureResponse = false;
            return;
        }
    }
    /**
     * Setter for `customConfigService` based on configuration passed.
     * Used internally during initialization.
     *
     * @param customConfigService - Custom configuration service to use
     */
    setCustomConfigService(customConfigService) {
        this.customConfigService = customConfigService ? customConfigService : undefined;
    }
    /**
     * Setter and initializer for `envVarsService`.
     * Used internally during initialization.
     */
    setEnvVarsService() {
        this.envVarsService = new config_1.EnvironmentVariablesService();
    }
    /**
     * Method that reconciles the configuration passed with the environment variables.
     * Used internally during initialization.
     *
     * @param options - Configuration passed to the tracer
     */
    setOptions(options) {
        const { enabled, serviceName, captureHTTPsRequests, customConfigService } = options;
        this.setEnvVarsService();
        this.setCustomConfigService(customConfigService);
        this.setTracingEnabled(enabled);
        this.setCaptureResponse();
        this.setCaptureError();
        this.setServiceName(serviceName);
        this.setCaptureHTTPsRequests(captureHTTPsRequests);
        return this;
    }
    /**
     * Setter for `customConfigService` based on configurations passed and environment variables.
     * Used internally during initialization.
     *
     * @param serviceName - Name of the service to use
     */
    setServiceName(serviceName) {
        if (serviceName !== undefined && Tracer.isValidServiceName(serviceName)) {
            this.serviceName = serviceName;
            return;
        }
        const customConfigValue = this.getCustomConfigService()?.getServiceName();
        if (customConfigValue !== undefined && Tracer.isValidServiceName(customConfigValue)) {
            this.serviceName = customConfigValue;
            return;
        }
        const envVarsValue = this.getEnvVarsService()?.getServiceName();
        if (envVarsValue !== undefined && Tracer.isValidServiceName(envVarsValue)) {
            this.serviceName = envVarsValue;
            return;
        }
    }
    /**
     * Setter for `tracingEnabled` based on configurations passed and environment variables.
     * Used internally during initialization.
     *
     * @param enabled - Whether or not tracing is enabled
     */
    setTracingEnabled(enabled) {
        if (enabled !== undefined && !enabled) {
            this.tracingEnabled = enabled;
            return;
        }
        const customConfigValue = this.getCustomConfigService()?.getTracingEnabled();
        if (customConfigValue !== undefined && customConfigValue.toLowerCase() === 'false') {
            this.tracingEnabled = false;
            return;
        }
        const envVarsValue = this.getEnvVarsService()?.getTracingEnabled();
        if (envVarsValue.toLowerCase() === 'false') {
            this.tracingEnabled = false;
            return;
        }
        if (this.isLambdaSamCli() || !this.isLambdaExecutionEnv()) {
            this.tracingEnabled = false;
        }
    }
}
exports.Tracer = Tracer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhY2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1RyYWNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSw0REFBeUQ7QUFFekQscUNBQStFO0FBRS9FLHlDQUF1RTtBQUN2RSx5REFBd0Q7QUFFeEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0dHO0FBQ0gsTUFBTSxNQUFPLFNBQVEsaUJBQU87SUFrQjFCLFlBQW1CLFVBQXlCLEVBQUU7UUFDNUMsS0FBSyxFQUFFLENBQUM7UUFmRixpQkFBWSxHQUFZLElBQUksQ0FBQztRQUU3Qix5QkFBb0IsR0FBWSxJQUFJLENBQUM7UUFFckMsb0JBQWUsR0FBWSxJQUFJLENBQUM7UUFRaEMsbUJBQWMsR0FBWSxJQUFJLENBQUM7UUFLckMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksMEJBQWUsRUFBRSxDQUFDO1FBQ3RDLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQ3hELElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztTQUNwQztRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRTtZQUM1QixxRkFBcUY7WUFDckYsSUFBSSxDQUFDLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDckQ7SUFDSCxDQUFDO0lBRUQ7Ozs7OztRQU1JO0lBQ0csa0JBQWtCLENBQUMsS0FBWTtRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDNUIsT0FBTztTQUNSO1FBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3RCLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUUxQixPQUFPO1NBQ1I7UUFFRCxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7Ozs7UUFPSTtJQUNHLHFCQUFxQixDQUFDLElBQWMsRUFBRSxVQUFtQjtRQUM5RCxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDM0UsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLFVBQVUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7O09BR0c7SUFDSSx3QkFBd0I7UUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssU0FBUyxFQUFFO1lBQzlELE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxpQkFBaUI7UUFDdEIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRTtZQUMzQixJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztTQUN0RDtJQUNILENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJHO0lBQ0ksVUFBVSxDQUFJLEdBQU07UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUFFLE9BQU8sR0FBRyxDQUFDO1FBRXpDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JHO0lBQ0ksZ0JBQWdCLENBQUksT0FBVTtRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQUUsT0FBTyxPQUFPLENBQUM7UUFFN0MsSUFBSTtZQUNGLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNoRDtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2QsSUFBSTtnQkFDRixzR0FBc0c7Z0JBQ3RHLG9EQUFvRDtnQkFDcEQsK0hBQStIO2dCQUMvSCxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFFLE9BQThCLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRXhFLE9BQU8sT0FBTyxDQUFDO2FBQ2hCO1lBQUMsTUFBTTtnQkFDTixNQUFNLEtBQUssQ0FBQzthQUNiO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJHO0lBQ0ksa0JBQWtCLENBQUksT0FBVTtRQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQUUsT0FBTyxPQUFPLENBQUM7UUFFN0MsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BOEJHO0lBQ0ksb0JBQW9CO1FBQ3pCLE9BQU8sQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxFQUFFO1lBQzFDLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUM7WUFFeEMsVUFBVSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsRUFBRTtnQkFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO29CQUM1QixPQUFPLGNBQWMsRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUUsQ0FBQyxDQUFDO2lCQUNwRTtnQkFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBQyxVQUFVLEVBQUMsRUFBRTtvQkFDckYsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7b0JBQ3pCLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO29CQUNoQyxJQUFJLE1BQWUsQ0FBQztvQkFDcEIsSUFBSTt3QkFDRixNQUFNLEdBQUcsTUFBTSxjQUFjLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFFLENBQUMsQ0FBQzt3QkFDM0UsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUMxRDtvQkFBQyxPQUFPLEtBQUssRUFBRTt3QkFDZCxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBYyxDQUFDLENBQUM7d0JBQ3hDLE1BQU0sS0FBSyxDQUFDO3FCQUNiOzRCQUFTO3dCQUNSLFVBQVUsRUFBRSxLQUFLLEVBQUUsQ0FBQzt3QkFDcEIsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDO3FCQUNyQjtvQkFFRCxPQUFPLE1BQU0sQ0FBQztnQkFDaEIsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQVksQ0FBQztZQUVkLE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtDRztJQUNJLGFBQWE7UUFDbEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLEVBQUU7WUFDMUMsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQztZQUV4QyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxJQUFlLEVBQUUsRUFBRTtnQkFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO29CQUM1QixPQUFPLGNBQWMsRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO2lCQUNqRDtnQkFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxjQUFjLENBQUMsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFDLFVBQVUsRUFBQyxFQUFFO29CQUNyRixJQUFJLE1BQU0sQ0FBQztvQkFDWCxJQUFJO3dCQUNGLE1BQU0sR0FBRyxNQUFNLGNBQWMsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO3dCQUN0RCxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDekQ7b0JBQUMsT0FBTyxLQUFLLEVBQUU7d0JBQ2QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQWMsQ0FBQyxDQUFDO3dCQUN4Qyw0SUFBNEk7d0JBQzVJLGVBQWU7cUJBQ2hCOzRCQUFTO3dCQUNSLFVBQVUsRUFBRSxLQUFLLEVBQUUsQ0FBQztxQkFDckI7b0JBRUQsT0FBTyxNQUFNLENBQUM7Z0JBQ2hCLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDO1lBRUYsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkc7SUFDSSxVQUFVO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO1lBQzVCLE9BQU8sSUFBSSw4QkFBVSxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDM0M7UUFDRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzNDLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLHlEQUF5RCxDQUFDLENBQUM7U0FDNUU7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLGdCQUFnQjtRQUNyQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7SUFDSSxhQUFhLENBQUMsR0FBVyxFQUFFLEtBQWdDO1FBQ2hFLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFBRSxPQUFPO1FBRXJDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNuQyxJQUFJLFFBQVEsWUFBWSwyQkFBTyxFQUFFO1lBQy9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsd0VBQXdFLENBQUMsQ0FBQztZQUV2RixPQUFPO1NBQ1I7UUFDRCxRQUFRLEVBQUUsYUFBYSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JHO0lBQ0ksV0FBVyxDQUFDLEdBQVcsRUFBRSxLQUFjLEVBQUUsU0FBOEI7UUFDNUUsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUFFLE9BQU87UUFFckMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ25DLElBQUksUUFBUSxZQUFZLDJCQUFPLEVBQUU7WUFDL0IsT0FBTyxDQUFDLElBQUksQ0FBQywrRUFBK0UsQ0FBQyxDQUFDO1lBRTlGLE9BQU87U0FDUjtRQUVELFNBQVMsR0FBRyxTQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMxQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkc7SUFDSSxVQUFVLENBQUMsT0FBNkI7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUFFLE9BQU87UUFFckMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssc0JBQXNCO1FBQzVCLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDO0lBQ2xDLENBQUM7SUFFRDs7O09BR0c7SUFDSyxpQkFBaUI7UUFDdkIsT0FBcUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssb0JBQW9CO1FBQzFCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLENBQUM7SUFDL0QsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGNBQWM7UUFDcEIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssTUFBTSxDQUFDLGtCQUFrQixDQUFDLFdBQW9CO1FBQ3BELE9BQU8sT0FBTyxXQUFXLEtBQUssUUFBUSxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7O09BR0c7SUFDSyxlQUFlO1FBQ3JCLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQztRQUNsRixJQUFJLGlCQUFpQixLQUFLLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDbEYsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7WUFFMUIsT0FBTztTQUNSO1FBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQztRQUN4RSxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDMUMsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7WUFFMUIsT0FBTztTQUNSO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSyx1QkFBdUIsQ0FBQyxPQUFpQjtRQUMvQyxJQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDckMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztZQUVsQyxPQUFPO1NBQ1I7UUFFRCxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxFQUFFLHVCQUF1QixFQUFFLENBQUM7UUFDbkYsSUFBSSxpQkFBaUIsS0FBSyxTQUFTLElBQUksaUJBQWlCLENBQUMsV0FBVyxFQUFFLEtBQUssT0FBTyxFQUFFO1lBQ2xGLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxLQUFLLENBQUM7WUFFbEMsT0FBTztTQUNSO1FBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQztRQUN6RSxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDMUMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztZQUVsQyxPQUFPO1NBQ1I7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssa0JBQWtCO1FBQ3hCLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUseUJBQXlCLEVBQUUsQ0FBQztRQUNyRixJQUFJLGlCQUFpQixLQUFLLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDbEYsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7WUFFN0IsT0FBTztTQUNSO1FBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUUseUJBQXlCLEVBQUUsQ0FBQztRQUMzRSxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDMUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7WUFFN0IsT0FBTztTQUNSO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssc0JBQXNCLENBQUMsbUJBQTRDO1FBQ3pFLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUNuRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssaUJBQWlCO1FBQ3ZCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxvQ0FBMkIsRUFBRSxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLFVBQVUsQ0FBQyxPQUFzQjtRQUN2QyxNQUFNLEVBQ0osT0FBTyxFQUNQLFdBQVcsRUFDWCxvQkFBb0IsRUFDcEIsbUJBQW1CLEVBQ3BCLEdBQUcsT0FBTyxDQUFDO1FBRVosSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLHNCQUFzQixDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBRW5ELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssY0FBYyxDQUFDLFdBQW9CO1FBQ3pDLElBQUksV0FBVyxLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDdkUsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7WUFFL0IsT0FBTztTQUNSO1FBRUQsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsRUFBRSxjQUFjLEVBQUUsQ0FBQztRQUMxRSxJQUFJLGlCQUFpQixLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUMsRUFBRTtZQUNuRixJQUFJLENBQUMsV0FBVyxHQUFHLGlCQUFpQixDQUFDO1lBRXJDLE9BQU87U0FDUjtRQUVELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLGNBQWMsRUFBRSxDQUFDO1FBQ2hFLElBQUksWUFBWSxLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDekUsSUFBSSxDQUFDLFdBQVcsR0FBRyxZQUFZLENBQUM7WUFFaEMsT0FBTztTQUNSO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssaUJBQWlCLENBQUMsT0FBaUI7UUFDekMsSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3JDLElBQUksQ0FBQyxjQUFjLEdBQUcsT0FBTyxDQUFDO1lBRTlCLE9BQU87U0FDUjtRQUVELE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQztRQUM3RSxJQUFJLGlCQUFpQixLQUFLLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDbEYsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7WUFFNUIsT0FBTztTQUNSO1FBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQztRQUNuRSxJQUFJLFlBQVksQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDMUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7WUFFNUIsT0FBTztTQUNSO1FBRUQsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBRTtZQUN6RCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztTQUM3QjtJQUNILENBQUM7Q0FFRjtBQUdDLHdCQUFNIn0=