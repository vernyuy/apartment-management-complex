"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = void 0;
const aws_cdk_lib_1 = require("aws-cdk-lib");
const config_1 = require("../config");
const alert_1 = require("./alert");
function hasDuplicates(array) {
    return (new Set(array)).size !== array.length;
}
function buildShortCalculation(cal) {
    if (cal.operation === "COUNT") {
        return cal.operation;
    }
    return `${cal.operation}(${cal.key})`;
}
function getCalculationAlias(cal) {
    return cal.alias ? cal.alias : buildShortCalculation(cal);
}
/**
 *
 */
class Query extends aws_cdk_lib_1.CfnResource {
    constructor(id, props) {
        var _a, _b;
        const stack = aws_cdk_lib_1.Stack.of(config_1.Baselime.getConstruct());
        const calcs = props.parameters.calculations;
        const orderByOptions = calcs === null || calcs === void 0 ? void 0 : calcs.map(cal => getCalculationAlias(cal));
        if ((calcs === null || calcs === void 0 ? void 0 : calcs.length) && hasDuplicates(calcs.filter(c => c.alias).map(c => c.alias))) {
            throw Error("Aliases must me unique across all calculations / visualisations.");
        }
        if (props.parameters.orderBy && !(orderByOptions === null || orderByOptions === void 0 ? void 0 : orderByOptions.includes(props.parameters.orderBy.value))) {
            throw Error("The orderBy must be present in the calculations / visualisations.");
        }
        const disableStackFilter = props.disableStackFilter || config_1.Baselime.getDisableStackFilter();
        if (!disableStackFilter) {
            (_a = props.parameters.filters) === null || _a === void 0 ? void 0 : _a.push({ operation: "=", key: "$baselime.stackId", value: stack.stackName });
        }
        const Parameters = Object.assign(Object.assign({}, props.parameters), { datasets: props.parameters.datasets || [], calculations: props.parameters.calculations || [], filters: props.parameters.filters, groupBys: (_b = props.parameters.groupBys) === null || _b === void 0 ? void 0 : _b.map(groupBy => {
                return Object.assign(Object.assign({}, groupBy), { type: (groupBy === null || groupBy === void 0 ? void 0 : groupBy.type) || "string" });
            }), filterCombination: props.parameters.filterCombination || "AND" });
        super(config_1.Baselime.getConstruct(), id, {
            type: "Custom::BaselimeQuery",
            properties: {
                id,
                ServiceToken: config_1.Baselime.getServiceToken(),
                BaselimeApiKey: config_1.Baselime.getApiKey(),
                Description: props.description,
                Parameters,
                Origin: "cdk"
            },
        });
        this.id = id;
        this.props = props;
    }
    addAlert(alert) {
        const alertProps = Object.assign(Object.assign({}, alert), { parameters: Object.assign(Object.assign({}, alert.parameters), { query: this }) });
        new alert_1.Alert(`${this.id}-alert`, alertProps);
    }
    addFilters(filters) {
        this.addPropertyOverride('Parameters.filters', [...filters || []]);
    }
}
exports.Query = Query;
;
//# sourceMappingURL=query.js.map